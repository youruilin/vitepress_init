# 页面导航

## 1.1 概述

页面导航指的是 页面之间的相互跳转 。例如，浏览器中实现页面导航的方式有如下两种：

① `<a>` 链接

② location.href

## 1.2 页面导航的两种方法

① 声明式导航

- 在页面上声明一个` <navigator>` 导航组件
- 通过点击 `<navigator>` 组件实现页面跳转

② 编程式导航

- 调用小程序的导航 APIAPI，实现页面的跳转

### 1.2.1 声明式导航-跳转至 tabBar 页面

在使用 ` <navigator> ` 组 件跳转到指定的 `tabBar` 页面时，需要指定 url 属性和 openopen-type 属性，其中：

- url 表示要跳转的 页面的地址 ，必须以 /开头
- openopen-type 表示 跳转的方式 ，必须为 switchTab示

```html
<navigator url="/pages/message/message" open-type="switchTab">导航到消息页面</navigator>
```

### 1.2.2 导航到非 tabBar 页面

非 tabBar 页面 指的是没有被配置为 tabBar 的页面。
在使用 `<navigator>` 组件跳转到普通的非 tabBar 页面时，则需要指定 url 属性和 openopen-type 属性，其中：

- url 表示要跳转的 页面的地址 ，必须以 /开头
- openopen-type 表示 跳转的方式 ，必须为 navigate

示例代码如下：

```html
<navigator url="/pages/info/info" open-type="navigate">导航到info页面</navigator>
```

::: details 声明式导航传参

navigator组件的 url 属性用来指定将要跳转到的页面的路径。同时， 路径的后面还可以携带参数 ：

- 参数 与路径 之间使用 ?分隔
- 参数键 与参数值 用 =相连
- 不同参数 用 &分隔

:::



::: tip 注意：

为了简便，在导航到非 tabBar 页面时， open -type=type="navigate"属性 可以省略 。

:::

### 1.2.3 后退导航

如果要后退到上一页面或多级页面，则需要指定openopen-type 属性和 delta 属性，其中：

- openopen-type 的值必须是 navigateBack ，表示要进行后退导航
- delta 的值必须是 数字 ，表示要后退的层级

示例代码如下：

```html
<navigator open-type="navigateBack" delta='1'>返回上一页</navigator>
```

::: tip 注意：

为了简便，如果只是后退到上一页面，则可以省略 delta 属性 ，因为其默认值就是 1。

:::

### 1.2.4 编程式导航 - 跳转到 tabBar  页面

调用 wx.switchTab(Object object object)方法，可以跳转到 tabBar 页面。其中 Object 参数对象 的属性列表如下：

|     属性     |    类型    | 必填 |                             说明                             |
| :----------: | :--------: | :--: | :----------------------------------------------------------: |
|   **url**    |  `string`  |  是  | 需要跳转的 tabBar 页面的路径（需在 `app.json` 的 `tabBar` 中定义），路径后不能带参数。 |
| **success**  | `function` |  否  |                   接口调用成功的回调函数。                   |
|   **fail**   | `function` |  否  |                   接口调用失败的回调函数。                   |
| **complete** | `function` |  否  |      接口调用结束的回调函数（调用成功、失败都会执行）。      |

示例代码如下：

```
// 页面结构
<button bindtap="gotoMessage">跳转到消息页面</button>

// 编程式导航跳转
gotoMessage() {
  wx.switchTab({
    url: '/pages/message/message'
  })
}
```

### 1.2.5  编程式导航 - 导航到非  tabBar  页面

|     属性     |    类型    | 必填 |                             说明                             |
| :----------: | :--------: | :--: | :----------------------------------------------------------: |
|   **url**    |  `string`  |  是  | 需要跳转的 tabBar 页面的路径（需在 `app.json` 的 `tabBar` 中定义），路径后可以带参数。 |
| **success**  | `function` |  否  |                   接口调用成功的回调函数。                   |
|   **fail**   | `function` |  否  |                   接口调用失败的回调函数。                   |
| **complete** | `function` |  否  |      接口调用结束的回调函数（调用成功、失败都会执行）。      |

```
<button bindtap="gotoMessage">跳转到info页面</button>

gotoMessage() {
  wx.navigateTo({
    url: '/pages/message/message'
  })
}
```

::: details 编程式导航传参

调用 wx.navigateTo()方法时，也可以携带参数跳转：

```
<button bindtap="gotoInfo2">跳转到info页面</button>

gotoInfo2() {
  wx.navigateTo({
    url: '/pages/info/info?name=ls&gender=男'
  })
}
```

:::

::: details 编程式导 - onLoad 中接收导航参数

通过声明导航传参或编程式导航传参所携带的参数，可以直接在 onLoad 实践中直接获取到：

```
/**
 * 生命周期函数--监听页面加载
 */
onLoad: function(options) {
  // options 就是导航传递过来的参数对象
  console.log(options)
}
```

:::



###1.2.6 编程式导航 - 后退导航

调用 wx.navigateBack(Object object object)方法，可以返回上一页面或多级页面。其中 Object 参数对象可选的属性列表如下：

|     属性     |    类型    | 必填 |                          说明                           |
| :----------: | :--------: | :--: | :-----------------------------------------------------: |
|  **delta**   |  `string`  |  是  | 返回的页面数，如果 delta 大于现有页面数，则返回到首页。 |
| **success**  | `function` |  否  |                接口调用成功的回调函数。                 |
|   **fail**   | `function` |  否  |                接口调用失败的回调函数。                 |
| **complete** | `function` |  否  |   接口调用结束的回调函数（调用成功、失败都会执行）。    |

```
// 页面结构
<button bindtap="gotoBack">跳转到消息页面</button>

// 编程式导航,后退到上一页或多页
gotoBack() {
  wx.navigateBack()
}
```



# 页面事件

## 下拉刷新

下拉刷新是移动端的专有名词，指的是通过手指在屏幕上的下拉滑动操作，从而重新加载页面数据的行为。

### 1.1 启用方式：

启用下拉刷新有两种方式：
① 全局开启下拉刷新

- 在 app.json 的 window 节点中，将 enablePullDownRefresh 设置为 true

② 局部开启下拉刷新

- 在页面的 .json 配置文件中，将 enablePullDownRefresh 设置为 true

在实际开发中，推荐使用第 2 种方式， 为需要的页面单独开启下拉刷新的效果 。

### 1.2 下拉窗口样式

在全局或页面的 .json 配置文件中，通过 backgroundColor 和 backgroundTextStyle 来配置下拉刷新窗口 的样式，其中：

- backgroundColor 用来配置下拉刷新 窗口的背景颜色 ，仅支持 16 进制的颜色值
- backgroundTextStyle 用来配置下拉刷新 loading 的样式 ，仅支持 dark 和 light

### 1.3 监听页面的下拉刷新事件

在页面的 .js 文件中，通过 onPullDownRefresh() 函数即可监听当前页面的下拉刷新事件。

例如，在页面的 wxml 中有如下的 UI 结构，点击按钮可以让 count 值自增 +1 ：

```html
// 页面结构
<view>count值为: {{count}}</view>
<button bindtap="countAdd">+1</button>

// +1 按钮的点击事件处理函数
countAdd() {
  this.setData({
    count: this.data.count + 1
  })
}
```

在触发页面的下拉刷新事件的时候，如果要把count 的值重置为 0：

```js
/**
 * 页面相关事件处理函数--监听用户下拉动作
 */
onPullDownRefresh: function () {
  this.setData({
    count: 0
  })
}
```

### 1.4 停止下拉刷新

当处理完下拉刷新后，下拉刷新的`loading`效果会一直显示， 不会主动消失 ，所以需要手动隐藏下拉刷新的`
loading`效果。

此时，调用 wx.stopPullDownRefresh() 可以停止当前页面的下拉刷新：

```js
/**
 * 页面相关事件处理函数--监听用户下拉动作
 */
onPullDownRefresh: function () {
  this.setData({
    count: 0
  })
  // 当数据重置成功之后, 调用此函数, 关闭下拉刷新的效果
  wx.stopPullDownRefresh()
}
```

## 上拉触底

上拉触底 是移动端的专有名词，通过手指在屏幕上的上拉滑动操作，从而 加载更多数据 的行为。

在页面的 .js 文件中，通过 onReachBottom() 函数即可监听当前页面的上拉触底事件：

```js
/**
 * 页面上拉触底事件的处理函数
 */
onReachBottom: function () {
  console.log('触发了上拉触底的事件')
}
```

### 配置上拉触底距离

上拉触底距离指的是 触发上拉触底事件时，滚动条距离页面底部的距离 。

可以在全局或页面的 .json 配置文件中，通过 onReachBottomDistance 属性来配置上拉触底的距离。

小程序默认的触底距离是50px ，在实际开发中，可以根据自己的需求修改这个默认值。

# 声明周期

## 概述

生命周期（Life Cycle Cycle）是指一个对象从 创建 -> 运行 -> 销毁 的整个阶段， 强调的是一个时间段 。例如：

- 张三 出生 ，表示这个人 生命周期的开始
- 张三 离世 ，表示这个人 生命周期的结束
- 中间张三的一生，就是张三的生命周期

我们可以把每个小程序运行的过程，也概括为生命周期：

- 小程序的 启动 ，表示 生命周期的开始
- 小程序的 关闭 ，表示 生命周期的结束
- 中间小程序运行的过程，就是小程序的生命周期

## 声明周期的分类

在小程序中，生命周期分为两类，分别是：
① 应用生命周期

- 特指小程序从启动 -> 运行 -> 销毁的过程

② 页面生命周期

- 特指小程序中，每个页面的加载 -> 渲染 -> 销毁的过程

其中， 页面的生命周期范围较小，应用程序的生命周期范围较大：

![image-20250722182745574](../../../public/image-声明周期.png)

## 生命周期函数

生命周期函数：是由小程序框架提供的内置函数，会伴随着生命周期自动按次序执行 。

生命周期函数的作用：允许程序员在特定的时间点 ，执行某些特定的操作。例如，页面刚加载的时候，可以在 onLoad 生命周期函数中初始化页面的数据。

::: tip 注意：

生命周期 强调的是 时间段，生命周期函数强调的是时间点 。

:::

小程序中的生命周期函数分为两类，分别是：

① 应用的生命周期函数

- 特指小程序从启动 -> 运行 -> 销毁期间依次调用的那些函数：

  ```js
  // app.js 文件
  App({
    // 小程序初始化完成时,执行此函数,全局只触发一次。可以做一些初始化的工作。
    onLaunch: function(options) { },
    // 小程序启动,或从后台进入前台显示时触发。
    onShow : function(options) { },
    // 小程序从前台进入后台时触发。
    onHide : function() { }
  })
  ```

② 页面的生命周期函数

- 特指小程序中，每个页面从加载 -> 渲染 -> 销毁期间依次调用的那些函数

  ```js
  // 页面的 .js 文件
  Page({
    onLoad : function(options) { }, // 监听页面加载, 一个页面只调用1次
    onShow : function() { },
    onReady : function() { }, // 监听页面初次渲染完成, 一个页面只调用1次
    onHide : function() { }, // 监听页面隐藏
    onUnload: function() { } // 监听页面卸载, 一个页面只调用1次
  8 })
  ```

# wxs 脚本

## 概述

WXS （WeiXin Script Script）是 小程序独有的一套脚本语言 ，结合 WXML ，可以构建出页面的结构。

wxml中无法调用在页面的 .js 中定义的函数， 但是wxml 中可以调用 wxs 中定义的函数。因此，小程序中wxs 的典型应用场景 就是“ 过滤器 ”。

虽然 wxs 的语法类似于 JavaScriptJavaScript，但是 wxs 和 JavaScript 是完全不同的两种语言：

① wxs 有自己的数据类型

- number 数值类型、 string 字符串类型、 boolean 布尔类型、 object 对象类型、
- function 函数类型、 array 数组类型、 date 日期类型、 regexp 正则

② wxs 不支持类似于 ES6 及以上的语法形式

- 不支持 ：let 、const 、解构赋值、展开运算符、箭头函数、对象属性简写、 etc...
- 支持 ：var 定义变量、普通 function 函数等类似于 ES5 的语法

③ wxs 遵循 CommonJS 规范

- module 对象
- require() 函数
- module.exports 对

## 基础语法

### 1. 内嵌 wxs 脚本

wxs代码可以编写在 wxml 文件中的 `<wxs>` 标签内，就像 Javascript 代码可以编写在 html 文件中的 `<script>`
标签内一样。
wxml文件中的每个` <wxs>` `</wxs>` 标签， 必须提供 module 属性 ，用来指定 当前 wxs 的模块名称 ，方便在 wxml 中访问模块中的成员：

```vue
<template>
  <view>{{m1.toUpper(username)}}</view>
</template>

<script module="m1" lang="wxs">
// 将文本转为大写形式 zs -> ZS
module.exports.toUpper = function(str) {
  return str.toUpperCase()
}
</script>
```

### 2. 定义外联的 wxs 脚本

wxs代码还可以编写在 以 .wxs 为后缀名的文件内 ，就像 javascript 代码可以 编写在.js 为后缀名的文件中 一样：

```js
// tools.wxs 文件
function toLower(str) {
    return str.toLowerCase()
}

module.exports = {
    toLower: toLower
}
```



### 3. 使用外联的 wxs 脚本

在 wxml 中引入外联的 wxs 脚本时， 必须为 `<wxs>` 标签添加 module 和 src 属性，其中：

- module 用来指定模块的名称

- src 用来指定要引入的脚本的路径，且必须是相对路径

  ```vue
  <!-- 调用 m2 模块中的方法 -->
  <view>{{m2.toLower(country)}}</view>
  
  <!-- 引用外联的 tools.wxs 脚本，并命名为 m2 (本身不参与渲染) -->
  <wxs src="../../utils/tools.wxs" module="m2"></wxs>
  ```

  

## wxs 的特点

1. 与 js 不同之处

   为了降低 wxswxs（WeiXin Script ）的学习成本 wxs 语言在设计时借大量鉴了 JavaScript 的语法。但是本质上，wxs 和 JavaScript 是完全不同的两种语言！

2. 不能作为组件的事件回调：

   wxs典型的应用场景就是“过滤器”，经常配合 Mustache 语法进行使用：

   ```
   <view>{{ m2.toLower(country) }}</view>
   ```

   在微信小程序的 **WXML 模板** 中，像 `country` 这样的变量可以直接使用（不需要写 `this.country`），是因为 WXML 的数据绑定机制会自动从当前页面的 **`data` 对象** 中查找该变量。这是小程序框架的设计特性，与 Vue（组合式api）等前端框架的数据绑定逻辑类似。

   但是，在 wxs 中定义的函数不能作为组件的事件回调函数 。因此，下面的用法是错误的：

   ```
   <button bindtap="m2.toLower">按钮</button>
   ```

3. 隔离性

   隔离性指的是 wxs 的运行环境和其他 JavaScript 代码是隔离的。体现在如下两方面：
   ① wxs 不能调用 js 中定义的函数

   ② wxs 不能调用小程序提供的 API

4. 性能好

   - 在 iOS 设备 上，小程序内的 WXS 会比 JavaScript 代码 快 2 ~ 20 倍
   - 在 android 设备 上，二者的运行效率

# 案例 - 本地生活

