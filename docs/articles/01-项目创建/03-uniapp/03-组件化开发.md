# 横向滑动组件

::: details - 点击查看详情

/src/pages/index/components/videoList.vue

```vue
<script setup lang="ts">
import { ref } from 'vue'

// 模拟视频数据
const videoList = ref([
  { src: '', zhanwei: '/static/images/videolist/video1.png' },
  { src: '', zhanwei: '/static/images/videolist/video2.png' },
  { src: '', zhanwei: '/static/images/videolist/video1.png' },
  { src: '', zhanwei: '/static/images/videolist/video1.png' },
])

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const scroll = (e: any) => {
  console.log('滚动中', e)
}
</script>

<template>
  <scroll-view
    class="scroll-view"
    :scroll-x="true"
    @scroll="scroll"
    scroll-left="120"
    :show-scrollbar="false"
  >
    <view
      v-for="(item, index) in videoList"
      :key="index"
      class="scroll-view-item"
    >
      <!-- 有视频源时显示视频 -->
      <video
        v-if="item.src"
        :src="item.src"
        class="video-item"
        :enable-play-gesture="true"
      ></video>
      <!-- 无视频源时显示占位图 -->
      <image
        v-else
        :src="item.zhanwei ? item.zhanwei : ''"
        class="placeholder-image"
        mode="aspectFill"
      ></image>
    </view>
  </scroll-view>
</template>

<style scoped lang="scss">
.scroll-view {
  white-space: nowrap;
  width: 100%;
  padding: 30rpx; // 同时设置了上下左右内边距，相当于滚动元素的固定父盒子

  .scroll-view-item {
    display: inline-block;
    width: 250rpx;
    height: 170rpx;
    border-radius: 16rpx;
    padding-right: 20rpx;
    overflow: hidden;
    position: relative;
    &:last-child {
      padding-right: 60rpx;
    }
  }
}

.video-item,
.placeholder-image {
  width: 100%;
  height: 100%;
  border-radius: 16rpx;
}
</style>
```

通过精准调试，发现横向滚动容器其子元素集中的padding样式，仅对元素集的其实元素左侧生效；

问题不在于 `padding` 或 `margin` 的选择，而在于**滚动容器的视口边界计算机制**：

- 滚动容器的**滚动边界**是基于**内容边界**计算的
- 任何 `padding` 或 `margin` 都只是在容器外部或内部创建空间
- 但**滚动停止位置**始终是内容边界对齐视口边界

```css
.scroll-view {
  white-space: nowrap;
  width: 100%;
  padding: 30rpx; // 同时设置了上下左右内边距，相当于滚动元素的固定父盒子
  .scroll-view-item {
    // 其他样式
    padding-right: 20rpx;
    &:last-child {
      padding-right: 60rpx;
    }
  }
}
```

- 滚动容器只关心**内容边界**
- 必须在**内容内部**扩展空间才能影响滚动边界
- 外部空间（margin/padding）只影响视觉布局，不影响滚动机制

:::



# 全局定义主题状态

## 实现逻辑

::: details - 点击查看详情

创建 styles/theme.scss

```scss
// styles/theme.scss

// ==================== 主题 Mixin 定义 ====================
@mixin light-theme {
  // 背景色系统
  --color-bg-page: #f5f7fa;
  --color-bg-card: #ffffff;
  --color-bg-navbar: linear-gradient(135deg, #03a9f0 20%, #0083fd 90%);
  --color-bg-transparent: rgba(255, 255, 255, 0.2);

  // 文字色系统
  --color-text-primary: #333333;
  --color-text-secondary: #666666;
  --color-text-tertiary: #999999;
  --color-text-white: #ffffff;

  // 功能色
  --color-success: #52c41a;
  --color-warning: #faad14;
  --color-error: #ff4d4f;
  --color-info: #1890ff;

  // 边框
  --color-border: #e0e0e0;
  --color-divider: #f0f0f0;
}

@mixin dark-theme {
  --color-bg-page: #1a1a1a;
  --color-bg-card: #2d2d2d;
  --color-bg-navbar: linear-gradient(135deg, #2c3e50 20%, #34495e 90%);
  --color-bg-transparent: rgba(255, 255, 255, 0.1);

  --color-text-primary: #ffffff;
  --color-text-secondary: #cccccc;
  --color-text-tertiary: #999999;
  --color-text-white: #ffffff;

  --color-success: #49aa19;
  --color-warning: #d89614;
  --color-error: #a61d24;
  --color-info: #177ddc;

  --color-border: #444444;
  --color-divider: #333333;
}

@mixin dusk-theme {
  --color-bg-page: #fdf6e3;
  --color-bg-card: #fff9e6;
  --color-bg-navbar: linear-gradient(135deg, #e67e22 20%, #d35400 90%);
  --color-bg-transparent: rgba(255, 255, 255, 0.3);

  --color-text-primary: #8b4513;
  --color-text-secondary: #a0522d;
  --color-text-tertiary: #cd853f;
  --color-text-white: #ffffff;

  --color-success: #389e0d;
  --color-warning: #d46b08;
  --color-error: #a8071a;
  --color-info: #0958d9;

  --color-border: #e6b88a;
  --color-divider: #f5e6d3;
}

// ==================== 页面级主题类 ====================
.theme {
  // 默认主题
  @include light-theme;

  // 主题类名
  &.light-mode {
    @include light-theme;
  }

  &.dark-mode {
    @include dark-theme;
  }

  &.dusk-mode {
    @include dusk-theme;
  }
}

// ==================== 通用样式类 ====================
.text-primary {
  color: var(--color-text-primary) !important;
}

.text-secondary {
  color: var(--color-text-secondary) !important;
}

.text-tertiary {
  color: var(--color-text-tertiary) !important;
}

.text-white {
  color: var(--color-text-white) !important;
}

.text-success {
  color: var(--color-success) !important;
}

.text-warning {
  color: var(--color-warning) !important;
}

.text-error {
  color: var(--color-error) !important;
}

.text-info {
  color: var(--color-info) !important;
}

.bg-page {
  background-color: var(--color-bg-page) !important;
}

.bg-card {
  background-color: var(--color-bg-card) !important;
}

.bg-transparent {
  background-color: var(--color-bg-transparent) !important;
}

.border {
  border: 1rpx solid var(--color-border) !important;
}

.divider {
  background-color: var(--color-divider) !important;
}
```

创建全局主题状态管理 `stores/modules/theme.ts`

简化版：

```ts
// stores/modules/theme.ts
import { defineStore } from 'pinia'
import { ref } from 'vue'

export type ThemeMode = 'light-mode' | 'dusk-mode' | 'dark-mode'

export const useThemeStore = defineStore(
  'theme',
  () => {
    // 当前主题
    const currentTheme = ref<ThemeMode>('light-mode')

    // 根据时间计算主题
    const calculateThemeByTime = (): ThemeMode => {
      const hour = new Date().getHours()
      if (hour >= 18 || hour < 6) return 'dark-mode'
      if (hour >= 16 && hour < 18) return 'dusk-mode'
      return 'light-mode'
    }

    // 自动更新主题
    const updateThemeByTime = () => {
      currentTheme.value = calculateThemeByTime()
    }

    // 手动设置主题
    const setTheme = (theme: ThemeMode) => {
      currentTheme.value = theme
    }

    // 切换主题
    const toggleTheme = () => {
      const themes: ThemeMode[] = ['light-mode', 'dusk-mode', 'dark-mode']
      const currentIndex = themes.indexOf(currentTheme.value)
      const nextIndex = (currentIndex + 1) % themes.length
      currentTheme.value = themes[nextIndex] ?? 'light-mode'
    }

    return {
      currentTheme,
      updateThemeByTime,
      setTheme,
      toggleTheme,
      calculateThemeByTime,
    }
  },
  {
    persist: {
      key: 'theme-store',
      storage: {
        getItem(key) {
          return uni.getStorageSync(key)
        },
        setItem(key, value) {
          uni.setStorageSync(key, value)
        },
      },
    },
  },
)
```

::: details - 原版对比

```ts
// stores/theme.ts
import { defineStore } from 'pinia'
import { computed, onUnmounted, ref } from 'vue'

export type ThemeMode = 'light-mode' | 'dusk-mode' | 'dark-mode'
export type ThemeSource = 'auto' | 'manual'

export const useThemeStore = defineStore(
  'theme',
  () => {
    // 状态
    const currentTheme = ref<ThemeMode>('light-mode')
    const themeSource = ref<ThemeSource>('auto') // 新增：主题来源
    let autoUpdateTimer: ReturnType<typeof setInterval> | null = null    // 新增：自动更新定时器

    // 计算属性
    const isAutoMode = computed(() => themeSource.value === 'auto')
    const suggestedTheme = computed(() => calculateThemeByTime())

    // 根据时间计算主题
    const calculateThemeByTime = (): ThemeMode => {
      const hour = new Date().getHours()
      if (hour >= 18 || hour < 6) return 'dark-mode'
      if (hour >= 16 && hour < 18) return 'dusk-mode'
      return 'light-mode'
    }

    // 自动更新主题
    const updateThemeByTime = () => {
      const newTheme = calculateThemeByTime()
      if (currentTheme.value !== newTheme) {
        currentTheme.value = newTheme
        console.log(`主题自动切换为: ${newTheme}`)
      }
    }

    // 手动设置主题（切换到手动模式）
    const setTheme = (theme: ThemeMode) => {
      currentTheme.value = theme
      themeSource.value = 'manual'
      stopAutoThemeUpdate() // 切换到手动模式时停止自动更新
      console.log(`主题手动设置为: ${theme}`)
    }

    // 切换到自动模式
    const enableAutoTheme = () => {
      themeSource.value = 'auto'
      updateThemeByTime()
      startAutoThemeUpdate()
      console.log('已启用自动主题切换')
    }

    // 启动自动主题更新（智能定时）
    const startAutoThemeUpdate = () => {
      stopAutoThemeUpdate() // 先停止现有定时器

      // 计算到下一个整点的延迟
      const now = new Date()
      const nextHour = new Date(now)
      nextHour.setHours(now.getHours() + 1, 0, 0, 0)
      const delay = nextHour.getTime() - now.getTime()

      // 设置定时器
      setTimeout(() => {
        updateThemeByTime()
        // 之后每小时更新一次
        autoUpdateTimer = setInterval(updateThemeByTime, 60 * 60 * 1000)
      }, delay)
    }

    // 停止自动主题更新
    const stopAutoThemeUpdate = () => {
      if (autoUpdateTimer) {
        clearInterval(autoUpdateTimer)
        autoUpdateTimer = null
      }
    }

    // 切换主题
    const toggleTheme = () => {
      const themes: ThemeMode[] = ['light-mode', 'dusk-mode', 'dark-mode']
      const currentIndex = themes.indexOf(currentTheme.value)
      const nextIndex = (currentIndex + 1) % themes.length
      setTheme(themes[nextIndex] ?? 'light-mode') // 使用 setTheme 来确保模式切换
    }

    // 初始化主题系统
    const initializeTheme = () => {
      if (themeSource.value === 'auto') {
        startAutoThemeUpdate()
      }
    }

    // 清理资源
    onUnmounted(() => {
      stopAutoThemeUpdate()
    })

    return {
      // 状态
      currentTheme,
      themeSource,
      // 计算属性
      isAutoMode,
      suggestedTheme,
      // 方法
      setTheme,
      enableAutoTheme,
      updateThemeByTime,
      toggleTheme,
      initializeTheme,
      stopAutoThemeUpdate,
      calculateThemeByTime,
    }
  },
  {
    persist: {
      key: 'theme-store',
      storage: {
        getItem(key) {
          const value = uni.getStorageSync(key)
          return value ? JSON.parse(value) : null
        },
        setItem(key, value) {
          uni.setStorageSync(key, JSON.stringify(value))
        },
      },
    },
  },
)
```

功能对比

| 功能               | 简化版       | 完整版        |
| :----------------- | :----------- | :------------ |
| **基础主题切换**   | ✅            | ✅             |
| **自动时间计算**   | ✅            | ✅             |
| **手动/自动模式**  | ❌            | ✅             |
| **智能定时更新**   | ❌            | ✅（整点检查） |
| **模式状态持久化** | ❌            | ✅             |
| **推荐主题提示**   | ❌            | ✅             |
| **资源自动清理**   | ❌            | ✅             |
| **日志输出**       | ❌            | ✅             |
| **性能优化**       | ⚠️ 每分钟检查 | ✅ 每小时检查  |

使用场景建议

使用简化版的情况：

- 小型项目
- 对性能要求不高
- 不需要手动/自动模式切换
- 开发原型阶段

使用完整版的情况：

- 生产环境项目
- 需要精细控制主题行为
- 重视性能和用户体验
- 需要完整的主题管理功能

推荐选择

**你的简化版完全够用**，因为：

1. 核心功能齐全
2. 代码简洁易维护
3. 满足大部分业务需求
4. 性能影响可以接受（每分钟检查一次）

只有在需要更精细的控制时才需要升级到完整版。简化版是很实用的设计！👍

:::

::: details - 后期优化方向

根据当地日出日落时间，来精准匹配主题的切换

:::

创建自动主题逻辑：

```ts
// services/themeService.ts
import { useThemeStore } from '@/stores/theme'

let themeTimer: number | null = null

export const startAutoThemeUpdate = () => {
  const themeStore = useThemeStore()
  
  // 立即更新一次
  themeStore.updateThemeByTime()
  
  // 设置定时器，每分钟检查一次
  themeTimer = setInterval(() => {
    themeStore.updateThemeByTime()
  }, 60 * 1000) // 1分钟
  
  return () => {
    if (themeTimer) {
      clearInterval(themeTimer)
      themeTimer = null
    }
  }
}

export const stopAutoThemeUpdate = () => {
  if (themeTimer) {
    clearInterval(themeTimer)
    themeTimer = null
  }
}
```

app.vue 中引入自动逻辑：

```vue
<script setup lang="ts">
import { onHide, onLaunch, onShow } from '@dcloudio/uni-app'

import { startAutoThemeUpdate } from '@/services/themeService' // [!code ++]
import { useThemeStore } from '@/stores' // [!code ++]

// 引入全局样式 // [!code ++]
import '@/styles/theme.scss' // [!code ++]

onLaunch(() => {
  console.log('App Launch')
  // 启动自动主题更新
  startAutoThemeUpdate() // [!code ++]
})
onShow(() => {
  console.log('App Show')
  // 应用从后台恢复时立即更新主题 // [!code ++]
  const themeStore = useThemeStore() // [!code ++]
  themeStore.updateThemeByTime() // [!code ++]
})
onHide(() => {
  console.log('App Hide')
})
</script>
```

:::

## 使用方法

::: details - 点击查看详情

以 headTop.vue 组件为例：

```vue
<script setup lang="ts">
import { useThemeStore, useWeatherStore } from '@/stores'
import { computed } from 'vue'

const weatherStore = useWeatherStore() // 全局天气状态
const themeStore = useThemeStore() // 使用全局主题store

// 删除本地的 themeClass、updateThemeByTime、timer 逻辑
// 这些现在由全局store管理

// 获取屏幕边界到安全区域距离
const { safeAreaInsets } = uni.getSystemInfoSync()
console.log(safeAreaInsets)

const greeting = computed(() => {
  const hour = new Date().getHours()

  if (hour >= 5 && hour < 9) {
    return '早上好'
  } else if (hour >= 9 && hour < 12) {
    return '上午好'
  } else if (hour >= 12 && hour < 14) {
    return '中午好'
  } else if (hour >= 14 && hour < 18) {
    return '下午好'
  } else {
    return '晚上好'
  }
})
</script>

<template>
  <view
    :class="['navbar', 'theme', themeStore.currentTheme]"
    :style="{ paddingTop: safeAreaInsets?.top + 'px' }"
  >
    <!-- top文字 -->
    <view class="top">
      <view class="top-left">
        <text class="hello-title">{{ greeting }}！</text>
        <text class="hello-dec">感谢您选择云峰农服</text>
      </view>
      <view class="top-right">.</view>
    </view>

    <!-- navBar-bottom -->
    <view class="navbar-bottom">
      <div class="location">
        <text class="iconfont location-icon">&#xe790;</text>
        <text class="info-text">牡丹区</text>
      </div>
      <div class="tianqi">
        <text class="tianqi-temp info-text">{{ weatherStore.weatherData?.tem }}°</text>
        <text class="tianqi-desc info-text">{{ weatherStore.weatherData?.wea }}</text>
      </div>
      <div class="shidu">
        <text class="iconfont shidu-icon">&#xe682;</text>
        <text class="info-text">65%</text>
      </div>
      <div class="air">
        <text class="iconfont air-icon">&#xe60e;</text>
        <text class="info-text air-text">良好</text>
      </div>
    </view>
  </view>
</template>

<style lang="scss">
/* 自定义导航条 */
.navbar {
  background-size: cover;
  position: relative;
  display: flex;
  flex-direction: column;
  padding-top: 10rpx;

  // 使用 CSS 变量定义背景
  background: var(--color-bg-navbar);

  .top {
    padding: 30rpx 30rpx 10rpx 30rpx;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;

    .top-left {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 10rpx;
      .hello-title {
        font-size: 40rpx;
        font-weight: 600;
        color: var(--color-text-white); // 使用 CSS 变量
      }
      .hello-dec {
        font-size: 26rpx;
        font-weight: 400;
        color: var(--color-text-white); // 使用 CSS 变量
        letter-spacing: 1rpx;
      }
    }

    .top-right {
      color: var(--color-info); // 使用 CSS 变量
    }
  }

  .navbar-bottom {
    display: flex;
    align-items: center;
    justify-content: space-between;
    height: 80rpx;
    padding: 10rpx 20rpx 50rpx 20rpx;
    margin-top: 30rpx;
    border-radius: 50rpx 50rpx 0 0;
    background-color: var(--color-bg-transparent); // 使用 CSS 变量

    // 统一所有子元素的样式
    .tianqi,
    .location,
    .shidu,
    .air {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      padding: 20rpx;
      gap: 8rpx;
      position: relative;

      // 每个元素都有竖杠
      &::after {
        content: '';
        position: absolute;
        right: 0;
        top: 50%;
        transform: translateY(-50%);
        width: 1rpx;
        height: 30rpx;
        background-color: var(--color-border); // 使用 CSS 变量
      }

      // 隐藏最后一个元素的竖杠
      &:last-child::after {
        display: none;
      }
    }

    .air-text {
      margin-left: 8rpx;
    }

    // 统一图标和文字样式
    .location-icon,
    .shidu-icon,
    .air-icon {
      color: var(--color-text-white); // 使用 CSS 变量
    }

    .location-icon {
      font-size: 32rpx;
    }

    .shidu-icon,
    .air-icon {
      font-size: 36rpx;
    }

    .info-text {
      font-size: 28rpx;
      color: var(--color-text-white); // 使用 CSS 变量
    }
  }
}
</style>
```

已经证实，只需要在尽可能顶级的标签中，添加全局 theme.scss 中定义的主题类名，既可以实现任意调用其中设定好的样式类名，其中还设置了默认主题为 light-theme：

``` scss
// ==================== 页面级主题类 ====================
.theme {
  // 默认主题
  @include light-theme;

  // 主题类名
  &.light-mode {
    @include light-theme;
  }

  &.dark-mode {
    @include dark-theme;
  }

  &.dusk-mode {
    @include dusk-theme;
  }
}
```

既可以实现全局样式的任意使用，其中：.theme 就是需要加入的类名；

而不强制必须引入全局 store 状态管理，这说明这是一个纯 css 实现方式， store 只负责管控主题状态！

一旦上级标签加入了这个类名，这么其子孙级标签，就可以直接使用`theme.scss`定义的全部类名样式，例如：

```scss
@mixin light-theme {
  // 背景色系统
  --color-bg-page: #f5f7fa;
  --color-bg-card: #ffffff;
  --color-bg-navbar: linear-gradient(135deg, #03a9f0 20%, #0083fd 90%);
  --color-bg-transparent: rgba(255, 255, 255, 0.2);

  // 文字色系统
  --color-text-primary: #333333;
  --color-text-secondary: #666666;
  --color-text-tertiary: #999999;
  --color-text-white: #ffffff;

  // 功能色
  --color-success: #52c41a;
  --color-warning: #faad14;
  --color-error: #ff4d4f;
  --color-info: #1890ff;

  // 边框
  --color-border: #e0e0e0;
  --color-divider: #f0f0f0;
}
```

:::

## 专属坑位

::: details - 点击查看详情

在页面和组件中，直接使用全局定义的样式类，发现不生效！！！

即使是定义了：

```scss
:root {
  // 背景色系统默认值
  --color-bg-page: #f5f7fa;
  --color-bg-card: #ffffff;
  --color-bg-navbar: linear-gradient(135deg, #f00366 20%, #0083fd 90%) !important;
  --color-bg-transparent: rgba(255, 255, 255, 0.2);

  // 文字色系统默认值
  --color-text-primary: #333333;
  --color-text-secondary: #666666;
  --color-text-tertiary: #999999;
  --color-text-white: #ffffff;

  // 其他变量...
}
```

也是没屌用，问题原因：

1. **小程序无传统 DOM**：没有 `:root`（即 `html` 元素）
2. **页面隔离**：每个页面是独立的 Webview
3. **样式作用域**：小程序的样式作用域与 Web 不同

:::

# 自定义tabbar的自动隐藏

::: details - 点击查看详情



:::
